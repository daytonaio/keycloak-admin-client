/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keycloak_admin_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// OrganizationsAPIService OrganizationsAPI service
type OrganizationsAPIService service

type ApiAdminRealmsRealmOrganizationsGetRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	realm string
	briefRepresentation *bool
	exact *bool
	first *int32
	max *int32
	q *string
	search *string
}

// if true, return the full representation. Otherwise, only the basic fields are returned.
func (r ApiAdminRealmsRealmOrganizationsGetRequest) BriefRepresentation(briefRepresentation bool) ApiAdminRealmsRealmOrganizationsGetRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

// Boolean which defines whether the param &#39;search&#39; must match exactly or not
func (r ApiAdminRealmsRealmOrganizationsGetRequest) Exact(exact bool) ApiAdminRealmsRealmOrganizationsGetRequest {
	r.exact = &exact
	return r
}

// The position of the first result to be processed (pagination offset)
func (r ApiAdminRealmsRealmOrganizationsGetRequest) First(first int32) ApiAdminRealmsRealmOrganizationsGetRequest {
	r.first = &first
	return r
}

// The maximum number of results to be returned - defaults to 10
func (r ApiAdminRealmsRealmOrganizationsGetRequest) Max(max int32) ApiAdminRealmsRealmOrganizationsGetRequest {
	r.max = &max
	return r
}

// A query to search for custom attributes, in the format &#39;key1:value2 key2:value2&#39;
func (r ApiAdminRealmsRealmOrganizationsGetRequest) Q(q string) ApiAdminRealmsRealmOrganizationsGetRequest {
	r.q = &q
	return r
}

// A String representing either an organization name or domain
func (r ApiAdminRealmsRealmOrganizationsGetRequest) Search(search string) ApiAdminRealmsRealmOrganizationsGetRequest {
	r.search = &search
	return r
}

func (r ApiAdminRealmsRealmOrganizationsGetRequest) Execute() ([]OrganizationRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsGetExecute(r)
}

/*
AdminRealmsRealmOrganizationsGet Returns a paginated list of organizations filtered according to the specified parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmOrganizationsGetRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsGet(ctx context.Context, realm string) ApiAdminRealmsRealmOrganizationsGetRequest {
	return ApiAdminRealmsRealmOrganizationsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
//  @return []OrganizationRepresentation
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsGetExecute(r ApiAdminRealmsRealmOrganizationsGetRequest) ([]OrganizationRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OrganizationRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "form", "")
	} else {
		var defaultValue bool = false
		r.briefRepresentation = &defaultValue
	}
	if r.exact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exact", r.exact, "form", "")
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "form", "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsMembersMemberIdOrganizationsGetRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	realm string
	memberId string
}

func (r ApiAdminRealmsRealmOrganizationsMembersMemberIdOrganizationsGetRequest) Execute() ([]OrganizationRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsMembersMemberIdOrganizationsGetExecute(r)
}

/*
AdminRealmsRealmOrganizationsMembersMemberIdOrganizationsGet Returns the organizations associated with the user that has the specified id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param memberId
 @return ApiAdminRealmsRealmOrganizationsMembersMemberIdOrganizationsGetRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsMembersMemberIdOrganizationsGet(ctx context.Context, realm string, memberId string) ApiAdminRealmsRealmOrganizationsMembersMemberIdOrganizationsGetRequest {
	return ApiAdminRealmsRealmOrganizationsMembersMemberIdOrganizationsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		memberId: memberId,
	}
}

// Execute executes the request
//  @return []OrganizationRepresentation
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsMembersMemberIdOrganizationsGetExecute(r ApiAdminRealmsRealmOrganizationsMembersMemberIdOrganizationsGetRequest) ([]OrganizationRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OrganizationRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsMembersMemberIdOrganizationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/members/{member-id}/organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"member-id"+"}", url.PathEscape(parameterValueToString(r.memberId, "memberId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsOrgIdDeleteRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	realm string
	orgId string
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsOrgIdDeleteExecute(r)
}

/*
AdminRealmsRealmOrganizationsOrgIdDelete Deletes the organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param orgId
 @return ApiAdminRealmsRealmOrganizationsOrgIdDeleteRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdDelete(ctx context.Context, realm string, orgId string) ApiAdminRealmsRealmOrganizationsOrgIdDeleteRequest {
	return ApiAdminRealmsRealmOrganizationsOrgIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		orgId: orgId,
	}
}

// Execute executes the request
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdDeleteExecute(r ApiAdminRealmsRealmOrganizationsOrgIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsOrgIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{org-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org-id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsOrgIdGetRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	realm string
	orgId string
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdGetRequest) Execute() (*OrganizationRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsOrgIdGetExecute(r)
}

/*
AdminRealmsRealmOrganizationsOrgIdGet Returns the organization representation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param orgId
 @return ApiAdminRealmsRealmOrganizationsOrgIdGetRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdGet(ctx context.Context, realm string, orgId string) ApiAdminRealmsRealmOrganizationsOrgIdGetRequest {
	return ApiAdminRealmsRealmOrganizationsOrgIdGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return OrganizationRepresentation
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdGetExecute(r ApiAdminRealmsRealmOrganizationsOrgIdGetRequest) (*OrganizationRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsOrgIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{org-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org-id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasDeleteRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	realm string
	orgId string
	alias string
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasDeleteExecute(r)
}

/*
AdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasDelete Removes the identity provider with the specified alias from the organization

Breaks the association between the identity provider and the organization. The provider itself is not deleted. If no provider is found, or if it is not currently associated with the org, an error response is returned

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param orgId
 @param alias
 @return ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasDeleteRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasDelete(ctx context.Context, realm string, orgId string, alias string) ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasDeleteRequest {
	return ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		orgId: orgId,
		alias: alias,
	}
}

// Execute executes the request
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasDeleteExecute(r ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{org-id}/identity-providers/{alias}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org-id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", url.PathEscape(parameterValueToString(r.alias, "alias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasGetRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	realm string
	orgId string
	alias string
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasGetRequest) Execute() (*IdentityProviderRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasGetExecute(r)
}

/*
AdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasGet Returns the identity provider associated with the organization that has the specified alias

Searches for an identity provider with the given alias. If one is found and is associated with the organization, it is returned. Otherwise, an error response with status NOT_FOUND is returned

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param orgId
 @param alias
 @return ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasGetRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasGet(ctx context.Context, realm string, orgId string, alias string) ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasGetRequest {
	return ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		orgId: orgId,
		alias: alias,
	}
}

// Execute executes the request
//  @return IdentityProviderRepresentation
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasGetExecute(r ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasGetRequest) (*IdentityProviderRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IdentityProviderRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsOrgIdIdentityProvidersAliasGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{org-id}/identity-providers/{alias}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org-id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", url.PathEscape(parameterValueToString(r.alias, "alias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersGetRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	realm string
	orgId string
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersGetRequest) Execute() ([]IdentityProviderRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsOrgIdIdentityProvidersGetExecute(r)
}

/*
AdminRealmsRealmOrganizationsOrgIdIdentityProvidersGet Returns all identity providers associated with the organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param orgId
 @return ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersGetRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdIdentityProvidersGet(ctx context.Context, realm string, orgId string) ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersGetRequest {
	return ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return []IdentityProviderRepresentation
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdIdentityProvidersGetExecute(r ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersGetRequest) ([]IdentityProviderRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IdentityProviderRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsOrgIdIdentityProvidersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{org-id}/identity-providers"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org-id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersPostRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	realm string
	orgId string
	body *string
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersPostRequest) Body(body string) ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersPostRequest {
	r.body = &body
	return r
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsOrgIdIdentityProvidersPostExecute(r)
}

/*
AdminRealmsRealmOrganizationsOrgIdIdentityProvidersPost Adds the identity provider with the specified id to the organization

Adds, or associates, an existing identity provider with the organization. If no identity provider is found, or if it is already associated with the organization, an error response is returned

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param orgId
 @return ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersPostRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdIdentityProvidersPost(ctx context.Context, realm string, orgId string) ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersPostRequest {
	return ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		orgId: orgId,
	}
}

// Execute executes the request
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdIdentityProvidersPostExecute(r ApiAdminRealmsRealmOrganizationsOrgIdIdentityProvidersPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsOrgIdIdentityProvidersPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{org-id}/identity-providers"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org-id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsOrgIdMembersCountGetRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	realm string
	orgId string
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdMembersCountGetRequest) Execute() (int64, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsOrgIdMembersCountGetExecute(r)
}

/*
AdminRealmsRealmOrganizationsOrgIdMembersCountGet Returns number of members in the organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param orgId
 @return ApiAdminRealmsRealmOrganizationsOrgIdMembersCountGetRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdMembersCountGet(ctx context.Context, realm string, orgId string) ApiAdminRealmsRealmOrganizationsOrgIdMembersCountGetRequest {
	return ApiAdminRealmsRealmOrganizationsOrgIdMembersCountGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return int64
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdMembersCountGetExecute(r ApiAdminRealmsRealmOrganizationsOrgIdMembersCountGetRequest) (int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsOrgIdMembersCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{org-id}/members/count"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org-id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsOrgIdMembersGetRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	realm string
	orgId string
	exact *bool
	first *int32
	max *int32
	membershipType *string
	search *string
}

// Boolean which defines whether the param &#39;search&#39; must match exactly or not
func (r ApiAdminRealmsRealmOrganizationsOrgIdMembersGetRequest) Exact(exact bool) ApiAdminRealmsRealmOrganizationsOrgIdMembersGetRequest {
	r.exact = &exact
	return r
}

// The position of the first result to be processed (pagination offset)
func (r ApiAdminRealmsRealmOrganizationsOrgIdMembersGetRequest) First(first int32) ApiAdminRealmsRealmOrganizationsOrgIdMembersGetRequest {
	r.first = &first
	return r
}

// The maximum number of results to be returned. Defaults to 10
func (r ApiAdminRealmsRealmOrganizationsOrgIdMembersGetRequest) Max(max int32) ApiAdminRealmsRealmOrganizationsOrgIdMembersGetRequest {
	r.max = &max
	return r
}

// The membership type
func (r ApiAdminRealmsRealmOrganizationsOrgIdMembersGetRequest) MembershipType(membershipType string) ApiAdminRealmsRealmOrganizationsOrgIdMembersGetRequest {
	r.membershipType = &membershipType
	return r
}

// A String representing either a member&#39;s username, e-mail, first name, or last name.
func (r ApiAdminRealmsRealmOrganizationsOrgIdMembersGetRequest) Search(search string) ApiAdminRealmsRealmOrganizationsOrgIdMembersGetRequest {
	r.search = &search
	return r
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdMembersGetRequest) Execute() ([]MemberRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsOrgIdMembersGetExecute(r)
}

/*
AdminRealmsRealmOrganizationsOrgIdMembersGet Returns a paginated list of organization members filtered according to the specified parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param orgId
 @return ApiAdminRealmsRealmOrganizationsOrgIdMembersGetRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdMembersGet(ctx context.Context, realm string, orgId string) ApiAdminRealmsRealmOrganizationsOrgIdMembersGetRequest {
	return ApiAdminRealmsRealmOrganizationsOrgIdMembersGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return []MemberRepresentation
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdMembersGetExecute(r ApiAdminRealmsRealmOrganizationsOrgIdMembersGetRequest) ([]MemberRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MemberRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsOrgIdMembersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{org-id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org-id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.exact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exact", r.exact, "form", "")
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "form", "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	}
	if r.membershipType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "membershipType", r.membershipType, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteExistingUserPostRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	realm string
	orgId string
	id *string
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteExistingUserPostRequest) Id(id string) ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteExistingUserPostRequest {
	r.id = &id
	return r
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteExistingUserPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsOrgIdMembersInviteExistingUserPostExecute(r)
}

/*
AdminRealmsRealmOrganizationsOrgIdMembersInviteExistingUserPost Invites an existing user to the organization, using the specified user id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param orgId
 @return ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteExistingUserPostRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdMembersInviteExistingUserPost(ctx context.Context, realm string, orgId string) ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteExistingUserPostRequest {
	return ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteExistingUserPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		orgId: orgId,
	}
}

// Execute executes the request
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdMembersInviteExistingUserPostExecute(r ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteExistingUserPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsOrgIdMembersInviteExistingUserPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{org-id}/members/invite-existing-user"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org-id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteUserPostRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	realm string
	orgId string
	email *string
	firstName *string
	lastName *string
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteUserPostRequest) Email(email string) ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteUserPostRequest {
	r.email = &email
	return r
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteUserPostRequest) FirstName(firstName string) ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteUserPostRequest {
	r.firstName = &firstName
	return r
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteUserPostRequest) LastName(lastName string) ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteUserPostRequest {
	r.lastName = &lastName
	return r
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteUserPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsOrgIdMembersInviteUserPostExecute(r)
}

/*
AdminRealmsRealmOrganizationsOrgIdMembersInviteUserPost Invites an existing user or sends a registration link to a new user, based on the provided e-mail address.

If the user with the given e-mail address exists, it sends an invitation link, otherwise it sends a registration link.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param orgId
 @return ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteUserPostRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdMembersInviteUserPost(ctx context.Context, realm string, orgId string) ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteUserPostRequest {
	return ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteUserPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		orgId: orgId,
	}
}

// Execute executes the request
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdMembersInviteUserPostExecute(r ApiAdminRealmsRealmOrganizationsOrgIdMembersInviteUserPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsOrgIdMembersInviteUserPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{org-id}/members/invite-user"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org-id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	}
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "firstName", r.firstName, "", "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "lastName", r.lastName, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsOrgIdMembersMemberIdDeleteRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	realm string
	orgId string
	memberId string
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdMembersMemberIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsOrgIdMembersMemberIdDeleteExecute(r)
}

/*
AdminRealmsRealmOrganizationsOrgIdMembersMemberIdDelete Removes the user with the specified id from the organization

Breaks the association between the user and organization. The user itself is deleted in case the membership is managed, otherwise the user is not deleted. If no user is found, or if they are not a member of the organization, an error response is returned

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param orgId
 @param memberId
 @return ApiAdminRealmsRealmOrganizationsOrgIdMembersMemberIdDeleteRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdMembersMemberIdDelete(ctx context.Context, realm string, orgId string, memberId string) ApiAdminRealmsRealmOrganizationsOrgIdMembersMemberIdDeleteRequest {
	return ApiAdminRealmsRealmOrganizationsOrgIdMembersMemberIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		orgId: orgId,
		memberId: memberId,
	}
}

// Execute executes the request
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdMembersMemberIdDeleteExecute(r ApiAdminRealmsRealmOrganizationsOrgIdMembersMemberIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsOrgIdMembersMemberIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{org-id}/members/{member-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org-id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"member-id"+"}", url.PathEscape(parameterValueToString(r.memberId, "memberId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsOrgIdMembersMemberIdGetRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	realm string
	orgId string
	memberId string
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdMembersMemberIdGetRequest) Execute() (*MemberRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsOrgIdMembersMemberIdGetExecute(r)
}

/*
AdminRealmsRealmOrganizationsOrgIdMembersMemberIdGet Returns the member of the organization with the specified id

Searches for auser with the given id. If one is found, and is currently a member of the organization, returns it. Otherwise,an error response with status NOT_FOUND is returned

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param orgId
 @param memberId
 @return ApiAdminRealmsRealmOrganizationsOrgIdMembersMemberIdGetRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdMembersMemberIdGet(ctx context.Context, realm string, orgId string, memberId string) ApiAdminRealmsRealmOrganizationsOrgIdMembersMemberIdGetRequest {
	return ApiAdminRealmsRealmOrganizationsOrgIdMembersMemberIdGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		orgId: orgId,
		memberId: memberId,
	}
}

// Execute executes the request
//  @return MemberRepresentation
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdMembersMemberIdGetExecute(r ApiAdminRealmsRealmOrganizationsOrgIdMembersMemberIdGetRequest) (*MemberRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MemberRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsOrgIdMembersMemberIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{org-id}/members/{member-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org-id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"member-id"+"}", url.PathEscape(parameterValueToString(r.memberId, "memberId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsOrgIdMembersMemberIdOrganizationsGetRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	realm string
	orgId string
	memberId string
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdMembersMemberIdOrganizationsGetRequest) Execute() ([]OrganizationRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsOrgIdMembersMemberIdOrganizationsGetExecute(r)
}

/*
AdminRealmsRealmOrganizationsOrgIdMembersMemberIdOrganizationsGet Returns the organizations associated with the user that has the specified id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param orgId
 @param memberId
 @return ApiAdminRealmsRealmOrganizationsOrgIdMembersMemberIdOrganizationsGetRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdMembersMemberIdOrganizationsGet(ctx context.Context, realm string, orgId string, memberId string) ApiAdminRealmsRealmOrganizationsOrgIdMembersMemberIdOrganizationsGetRequest {
	return ApiAdminRealmsRealmOrganizationsOrgIdMembersMemberIdOrganizationsGetRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		orgId: orgId,
		memberId: memberId,
	}
}

// Execute executes the request
//  @return []OrganizationRepresentation
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdMembersMemberIdOrganizationsGetExecute(r ApiAdminRealmsRealmOrganizationsOrgIdMembersMemberIdOrganizationsGetRequest) ([]OrganizationRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OrganizationRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsOrgIdMembersMemberIdOrganizationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{org-id}/members/{member-id}/organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org-id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"member-id"+"}", url.PathEscape(parameterValueToString(r.memberId, "memberId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsOrgIdMembersPostRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	realm string
	orgId string
	body *string
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdMembersPostRequest) Body(body string) ApiAdminRealmsRealmOrganizationsOrgIdMembersPostRequest {
	r.body = &body
	return r
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdMembersPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsOrgIdMembersPostExecute(r)
}

/*
AdminRealmsRealmOrganizationsOrgIdMembersPost Adds the user with the specified id as a member of the organization

Adds, or associates, an existing user with the organization. If no user is found, or if it is already associated with the organization, an error response is returned

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param orgId
 @return ApiAdminRealmsRealmOrganizationsOrgIdMembersPostRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdMembersPost(ctx context.Context, realm string, orgId string) ApiAdminRealmsRealmOrganizationsOrgIdMembersPostRequest {
	return ApiAdminRealmsRealmOrganizationsOrgIdMembersPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		orgId: orgId,
	}
}

// Execute executes the request
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdMembersPostExecute(r ApiAdminRealmsRealmOrganizationsOrgIdMembersPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsOrgIdMembersPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{org-id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org-id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsOrgIdPutRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	realm string
	orgId string
	organizationRepresentation *OrganizationRepresentation
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdPutRequest) OrganizationRepresentation(organizationRepresentation OrganizationRepresentation) ApiAdminRealmsRealmOrganizationsOrgIdPutRequest {
	r.organizationRepresentation = &organizationRepresentation
	return r
}

func (r ApiAdminRealmsRealmOrganizationsOrgIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsOrgIdPutExecute(r)
}

/*
AdminRealmsRealmOrganizationsOrgIdPut Updates the organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @param orgId
 @return ApiAdminRealmsRealmOrganizationsOrgIdPutRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdPut(ctx context.Context, realm string, orgId string) ApiAdminRealmsRealmOrganizationsOrgIdPutRequest {
	return ApiAdminRealmsRealmOrganizationsOrgIdPutRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
		orgId: orgId,
	}
}

// Execute executes the request
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsOrgIdPutExecute(r ApiAdminRealmsRealmOrganizationsOrgIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsOrgIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{org-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org-id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.organizationRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsPostRequest struct {
	ctx context.Context
	ApiService *OrganizationsAPIService
	realm string
	organizationRepresentation *OrganizationRepresentation
}

func (r ApiAdminRealmsRealmOrganizationsPostRequest) OrganizationRepresentation(organizationRepresentation OrganizationRepresentation) ApiAdminRealmsRealmOrganizationsPostRequest {
	r.organizationRepresentation = &organizationRepresentation
	return r
}

func (r ApiAdminRealmsRealmOrganizationsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsPostExecute(r)
}

/*
AdminRealmsRealmOrganizationsPost Creates a new organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param realm realm name (not id!)
 @return ApiAdminRealmsRealmOrganizationsPostRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsPost(ctx context.Context, realm string) ApiAdminRealmsRealmOrganizationsPostRequest {
	return ApiAdminRealmsRealmOrganizationsPostRequest{
		ApiService: a,
		ctx: ctx,
		realm: realm,
	}
}

// Execute executes the request
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsPostExecute(r ApiAdminRealmsRealmOrganizationsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.organizationRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
