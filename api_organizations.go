/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keycloak_admin_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// OrganizationsAPIService OrganizationsAPI service
type OrganizationsAPIService service

type ApiAdminRealmsRealmOrganizationsGetRequest struct {
	ctx        context.Context
	ApiService *OrganizationsAPIService
	realm      string
	exact      *bool
	first      *int32
	max        *int32
	q          *string
	search     *string
}

// Boolean which defines whether the param &#39;search&#39; must match exactly or not
func (r ApiAdminRealmsRealmOrganizationsGetRequest) Exact(exact bool) ApiAdminRealmsRealmOrganizationsGetRequest {
	r.exact = &exact
	return r
}

// The position of the first result to be processed (pagination offset)
func (r ApiAdminRealmsRealmOrganizationsGetRequest) First(first int32) ApiAdminRealmsRealmOrganizationsGetRequest {
	r.first = &first
	return r
}

// The maximum number of results to be returned - defaults to 10
func (r ApiAdminRealmsRealmOrganizationsGetRequest) Max(max int32) ApiAdminRealmsRealmOrganizationsGetRequest {
	r.max = &max
	return r
}

// A query to search for custom attributes, in the format &#39;key1:value2 key2:value2&#39;
func (r ApiAdminRealmsRealmOrganizationsGetRequest) Q(q string) ApiAdminRealmsRealmOrganizationsGetRequest {
	r.q = &q
	return r
}

// A String representing either an organization name or domain
func (r ApiAdminRealmsRealmOrganizationsGetRequest) Search(search string) ApiAdminRealmsRealmOrganizationsGetRequest {
	r.search = &search
	return r
}

func (r ApiAdminRealmsRealmOrganizationsGetRequest) Execute() ([]OrganizationRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsGetExecute(r)
}

/*
AdminRealmsRealmOrganizationsGet Returns a paginated list of organizations filtered according to the specified parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return ApiAdminRealmsRealmOrganizationsGetRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsGet(ctx context.Context, realm string) ApiAdminRealmsRealmOrganizationsGetRequest {
	return ApiAdminRealmsRealmOrganizationsGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
//
//	@return	[]OrganizationRepresentation
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsGetExecute(r ApiAdminRealmsRealmOrganizationsGetRequest) ([]OrganizationRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []OrganizationRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.exact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exact", r.exact, "form", "")
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "form", "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsIdDeleteRequest struct {
	ctx        context.Context
	ApiService *OrganizationsAPIService
	realm      string
	id         string
}

func (r ApiAdminRealmsRealmOrganizationsIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsIdDeleteExecute(r)
}

/*
AdminRealmsRealmOrganizationsIdDelete Deletes the organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiAdminRealmsRealmOrganizationsIdDeleteRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdDelete(ctx context.Context, realm string, id string) ApiAdminRealmsRealmOrganizationsIdDeleteRequest {
	return ApiAdminRealmsRealmOrganizationsIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdDeleteExecute(r ApiAdminRealmsRealmOrganizationsIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsIdGetRequest struct {
	ctx        context.Context
	ApiService *OrganizationsAPIService
	realm      string
	id         string
}

func (r ApiAdminRealmsRealmOrganizationsIdGetRequest) Execute() (*OrganizationRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsIdGetExecute(r)
}

/*
AdminRealmsRealmOrganizationsIdGet Returns the organization representation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiAdminRealmsRealmOrganizationsIdGetRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdGet(ctx context.Context, realm string, id string) ApiAdminRealmsRealmOrganizationsIdGetRequest {
	return ApiAdminRealmsRealmOrganizationsIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return	OrganizationRepresentation
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdGetExecute(r ApiAdminRealmsRealmOrganizationsIdGetRequest) (*OrganizationRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OrganizationRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsIdIdentityProvidersAliasDeleteRequest struct {
	ctx        context.Context
	ApiService *OrganizationsAPIService
	realm      string
	id         string
	alias      string
}

func (r ApiAdminRealmsRealmOrganizationsIdIdentityProvidersAliasDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsIdIdentityProvidersAliasDeleteExecute(r)
}

/*
AdminRealmsRealmOrganizationsIdIdentityProvidersAliasDelete Removes the identity provider with the specified alias from the organization

Breaks the association between the identity provider and the organization. The provider itself is not deleted. If no provider is found, or if it is not currently associated with the org, an error response is returned

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param alias
	@return ApiAdminRealmsRealmOrganizationsIdIdentityProvidersAliasDeleteRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdIdentityProvidersAliasDelete(ctx context.Context, realm string, id string, alias string) ApiAdminRealmsRealmOrganizationsIdIdentityProvidersAliasDeleteRequest {
	return ApiAdminRealmsRealmOrganizationsIdIdentityProvidersAliasDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		alias:      alias,
	}
}

// Execute executes the request
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdIdentityProvidersAliasDeleteExecute(r ApiAdminRealmsRealmOrganizationsIdIdentityProvidersAliasDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsIdIdentityProvidersAliasDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{id}/identity-providers/{alias}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", url.PathEscape(parameterValueToString(r.alias, "alias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsIdIdentityProvidersAliasGetRequest struct {
	ctx        context.Context
	ApiService *OrganizationsAPIService
	realm      string
	id         string
	alias      string
}

func (r ApiAdminRealmsRealmOrganizationsIdIdentityProvidersAliasGetRequest) Execute() (*IdentityProviderRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsIdIdentityProvidersAliasGetExecute(r)
}

/*
AdminRealmsRealmOrganizationsIdIdentityProvidersAliasGet Returns the identity provider associated with the organization that has the specified alias

Searches for an identity provider with the given alias. If one is found and is associated with the organization, it is returned. Otherwise, an error response with status NOT_FOUND is returned

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param alias
	@return ApiAdminRealmsRealmOrganizationsIdIdentityProvidersAliasGetRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdIdentityProvidersAliasGet(ctx context.Context, realm string, id string, alias string) ApiAdminRealmsRealmOrganizationsIdIdentityProvidersAliasGetRequest {
	return ApiAdminRealmsRealmOrganizationsIdIdentityProvidersAliasGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		alias:      alias,
	}
}

// Execute executes the request
//
//	@return	IdentityProviderRepresentation
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdIdentityProvidersAliasGetExecute(r ApiAdminRealmsRealmOrganizationsIdIdentityProvidersAliasGetRequest) (*IdentityProviderRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IdentityProviderRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsIdIdentityProvidersAliasGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{id}/identity-providers/{alias}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", url.PathEscape(parameterValueToString(r.alias, "alias")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsIdIdentityProvidersGetRequest struct {
	ctx        context.Context
	ApiService *OrganizationsAPIService
	realm      string
	id         string
}

func (r ApiAdminRealmsRealmOrganizationsIdIdentityProvidersGetRequest) Execute() ([]IdentityProviderRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsIdIdentityProvidersGetExecute(r)
}

/*
AdminRealmsRealmOrganizationsIdIdentityProvidersGet Returns all identity providers associated with the organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiAdminRealmsRealmOrganizationsIdIdentityProvidersGetRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdIdentityProvidersGet(ctx context.Context, realm string, id string) ApiAdminRealmsRealmOrganizationsIdIdentityProvidersGetRequest {
	return ApiAdminRealmsRealmOrganizationsIdIdentityProvidersGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return	[]IdentityProviderRepresentation
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdIdentityProvidersGetExecute(r ApiAdminRealmsRealmOrganizationsIdIdentityProvidersGetRequest) ([]IdentityProviderRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []IdentityProviderRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsIdIdentityProvidersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{id}/identity-providers"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsIdIdentityProvidersPostRequest struct {
	ctx        context.Context
	ApiService *OrganizationsAPIService
	realm      string
	id         string
	body       *string
}

func (r ApiAdminRealmsRealmOrganizationsIdIdentityProvidersPostRequest) Body(body string) ApiAdminRealmsRealmOrganizationsIdIdentityProvidersPostRequest {
	r.body = &body
	return r
}

func (r ApiAdminRealmsRealmOrganizationsIdIdentityProvidersPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsIdIdentityProvidersPostExecute(r)
}

/*
AdminRealmsRealmOrganizationsIdIdentityProvidersPost Adds the identity provider with the specified id to the organization

Adds, or associates, an existing identity provider with the organization. If no identity provider is found, or if it is already associated with the organization, an error response is returned

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiAdminRealmsRealmOrganizationsIdIdentityProvidersPostRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdIdentityProvidersPost(ctx context.Context, realm string, id string) ApiAdminRealmsRealmOrganizationsIdIdentityProvidersPostRequest {
	return ApiAdminRealmsRealmOrganizationsIdIdentityProvidersPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdIdentityProvidersPostExecute(r ApiAdminRealmsRealmOrganizationsIdIdentityProvidersPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsIdIdentityProvidersPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{id}/identity-providers"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsIdMembersCountGetRequest struct {
	ctx        context.Context
	ApiService *OrganizationsAPIService
	realm      string
	id         string
}

func (r ApiAdminRealmsRealmOrganizationsIdMembersCountGetRequest) Execute() (int64, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsIdMembersCountGetExecute(r)
}

/*
AdminRealmsRealmOrganizationsIdMembersCountGet Returns number of members in the organization.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiAdminRealmsRealmOrganizationsIdMembersCountGetRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdMembersCountGet(ctx context.Context, realm string, id string) ApiAdminRealmsRealmOrganizationsIdMembersCountGetRequest {
	return ApiAdminRealmsRealmOrganizationsIdMembersCountGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return	int64
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdMembersCountGetExecute(r ApiAdminRealmsRealmOrganizationsIdMembersCountGetRequest) (int64, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsIdMembersCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{id}/members/count"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsIdMembersGetRequest struct {
	ctx        context.Context
	ApiService *OrganizationsAPIService
	realm      string
	id         string
	exact      *bool
	first      *int32
	max        *int32
	search     *string
}

// Boolean which defines whether the param &#39;search&#39; must match exactly or not
func (r ApiAdminRealmsRealmOrganizationsIdMembersGetRequest) Exact(exact bool) ApiAdminRealmsRealmOrganizationsIdMembersGetRequest {
	r.exact = &exact
	return r
}

// The position of the first result to be processed (pagination offset)
func (r ApiAdminRealmsRealmOrganizationsIdMembersGetRequest) First(first int32) ApiAdminRealmsRealmOrganizationsIdMembersGetRequest {
	r.first = &first
	return r
}

// The maximum number of results to be returned. Defaults to 10
func (r ApiAdminRealmsRealmOrganizationsIdMembersGetRequest) Max(max int32) ApiAdminRealmsRealmOrganizationsIdMembersGetRequest {
	r.max = &max
	return r
}

// A String representing either a member&#39;s username, e-mail, first name, or last name.
func (r ApiAdminRealmsRealmOrganizationsIdMembersGetRequest) Search(search string) ApiAdminRealmsRealmOrganizationsIdMembersGetRequest {
	r.search = &search
	return r
}

func (r ApiAdminRealmsRealmOrganizationsIdMembersGetRequest) Execute() ([]MemberRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsIdMembersGetExecute(r)
}

/*
AdminRealmsRealmOrganizationsIdMembersGet Returns a paginated list of organization members filtered according to the specified parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiAdminRealmsRealmOrganizationsIdMembersGetRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdMembersGet(ctx context.Context, realm string, id string) ApiAdminRealmsRealmOrganizationsIdMembersGetRequest {
	return ApiAdminRealmsRealmOrganizationsIdMembersGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return	[]MemberRepresentation
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdMembersGetExecute(r ApiAdminRealmsRealmOrganizationsIdMembersGetRequest) ([]MemberRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []MemberRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsIdMembersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.exact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exact", r.exact, "form", "")
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "form", "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsIdMembersInviteExistingUserPostRequest struct {
	ctx        context.Context
	ApiService *OrganizationsAPIService
	realm      string
	id         string
	id2        *string
}

func (r ApiAdminRealmsRealmOrganizationsIdMembersInviteExistingUserPostRequest) Id2(id2 string) ApiAdminRealmsRealmOrganizationsIdMembersInviteExistingUserPostRequest {
	r.id2 = &id2
	return r
}

func (r ApiAdminRealmsRealmOrganizationsIdMembersInviteExistingUserPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsIdMembersInviteExistingUserPostExecute(r)
}

/*
AdminRealmsRealmOrganizationsIdMembersInviteExistingUserPost Invites an existing user to the organization, using the specified user id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiAdminRealmsRealmOrganizationsIdMembersInviteExistingUserPostRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdMembersInviteExistingUserPost(ctx context.Context, realm string, id string) ApiAdminRealmsRealmOrganizationsIdMembersInviteExistingUserPostRequest {
	return ApiAdminRealmsRealmOrganizationsIdMembersInviteExistingUserPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdMembersInviteExistingUserPostExecute(r ApiAdminRealmsRealmOrganizationsIdMembersInviteExistingUserPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsIdMembersInviteExistingUserPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{id}/members/invite-existing-user"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id2, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsIdMembersInviteUserPostRequest struct {
	ctx        context.Context
	ApiService *OrganizationsAPIService
	realm      string
	id         string
	email      *string
	firstName  *string
	lastName   *string
}

func (r ApiAdminRealmsRealmOrganizationsIdMembersInviteUserPostRequest) Email(email string) ApiAdminRealmsRealmOrganizationsIdMembersInviteUserPostRequest {
	r.email = &email
	return r
}

func (r ApiAdminRealmsRealmOrganizationsIdMembersInviteUserPostRequest) FirstName(firstName string) ApiAdminRealmsRealmOrganizationsIdMembersInviteUserPostRequest {
	r.firstName = &firstName
	return r
}

func (r ApiAdminRealmsRealmOrganizationsIdMembersInviteUserPostRequest) LastName(lastName string) ApiAdminRealmsRealmOrganizationsIdMembersInviteUserPostRequest {
	r.lastName = &lastName
	return r
}

func (r ApiAdminRealmsRealmOrganizationsIdMembersInviteUserPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsIdMembersInviteUserPostExecute(r)
}

/*
AdminRealmsRealmOrganizationsIdMembersInviteUserPost Invites an existing user or sends a registration link to a new user, based on the provided e-mail address.

If the user with the given e-mail address exists, it sends an invitation link, otherwise it sends a registration link.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiAdminRealmsRealmOrganizationsIdMembersInviteUserPostRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdMembersInviteUserPost(ctx context.Context, realm string, id string) ApiAdminRealmsRealmOrganizationsIdMembersInviteUserPostRequest {
	return ApiAdminRealmsRealmOrganizationsIdMembersInviteUserPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdMembersInviteUserPostExecute(r ApiAdminRealmsRealmOrganizationsIdMembersInviteUserPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsIdMembersInviteUserPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{id}/members/invite-user"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	}
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "firstName", r.firstName, "", "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "lastName", r.lastName, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsIdMembersPostRequest struct {
	ctx        context.Context
	ApiService *OrganizationsAPIService
	realm      string
	id         string
	body       *string
}

func (r ApiAdminRealmsRealmOrganizationsIdMembersPostRequest) Body(body string) ApiAdminRealmsRealmOrganizationsIdMembersPostRequest {
	r.body = &body
	return r
}

func (r ApiAdminRealmsRealmOrganizationsIdMembersPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsIdMembersPostExecute(r)
}

/*
AdminRealmsRealmOrganizationsIdMembersPost Adds the user with the specified id as a member of the organization

Adds, or associates, an existing user with the organization. If no user is found, or if it is already associated with the organization, an error response is returned

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiAdminRealmsRealmOrganizationsIdMembersPostRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdMembersPost(ctx context.Context, realm string, id string) ApiAdminRealmsRealmOrganizationsIdMembersPostRequest {
	return ApiAdminRealmsRealmOrganizationsIdMembersPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdMembersPostExecute(r ApiAdminRealmsRealmOrganizationsIdMembersPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsIdMembersPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsIdMembersUserIdDeleteRequest struct {
	ctx        context.Context
	ApiService *OrganizationsAPIService
	realm      string
	id         string
	userId     string
}

func (r ApiAdminRealmsRealmOrganizationsIdMembersUserIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsIdMembersUserIdDeleteExecute(r)
}

/*
AdminRealmsRealmOrganizationsIdMembersUserIdDelete Removes the user with the specified id from the organization

Breaks the association between the user and organization. The user itself is deleted in case the membership is managed, otherwise the user is not deleted. If no user is found, or if they are not a member of the organization, an error response is returned

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param userId
	@return ApiAdminRealmsRealmOrganizationsIdMembersUserIdDeleteRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdMembersUserIdDelete(ctx context.Context, realm string, id string, userId string) ApiAdminRealmsRealmOrganizationsIdMembersUserIdDeleteRequest {
	return ApiAdminRealmsRealmOrganizationsIdMembersUserIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		userId:     userId,
	}
}

// Execute executes the request
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdMembersUserIdDeleteExecute(r ApiAdminRealmsRealmOrganizationsIdMembersUserIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsIdMembersUserIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{id}/members/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsIdMembersUserIdGetRequest struct {
	ctx        context.Context
	ApiService *OrganizationsAPIService
	realm      string
	id         string
	userId     string
}

func (r ApiAdminRealmsRealmOrganizationsIdMembersUserIdGetRequest) Execute() (*MemberRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsIdMembersUserIdGetExecute(r)
}

/*
AdminRealmsRealmOrganizationsIdMembersUserIdGet Returns the member of the organization with the specified id

Searches for auser with the given id. If one is found, and is currently a member of the organization, returns it. Otherwise,an error response with status NOT_FOUND is returned

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param userId
	@return ApiAdminRealmsRealmOrganizationsIdMembersUserIdGetRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdMembersUserIdGet(ctx context.Context, realm string, id string, userId string) ApiAdminRealmsRealmOrganizationsIdMembersUserIdGetRequest {
	return ApiAdminRealmsRealmOrganizationsIdMembersUserIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return	MemberRepresentation
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdMembersUserIdGetExecute(r ApiAdminRealmsRealmOrganizationsIdMembersUserIdGetRequest) (*MemberRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MemberRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsIdMembersUserIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{id}/members/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsIdMembersUserIdOrganizationsGetRequest struct {
	ctx        context.Context
	ApiService *OrganizationsAPIService
	realm      string
	id         string
	userId     string
}

func (r ApiAdminRealmsRealmOrganizationsIdMembersUserIdOrganizationsGetRequest) Execute() ([]OrganizationRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsIdMembersUserIdOrganizationsGetExecute(r)
}

/*
AdminRealmsRealmOrganizationsIdMembersUserIdOrganizationsGet Returns the organizations associated with the user that has the specified id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param userId
	@return ApiAdminRealmsRealmOrganizationsIdMembersUserIdOrganizationsGetRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdMembersUserIdOrganizationsGet(ctx context.Context, realm string, id string, userId string) ApiAdminRealmsRealmOrganizationsIdMembersUserIdOrganizationsGetRequest {
	return ApiAdminRealmsRealmOrganizationsIdMembersUserIdOrganizationsGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return	[]OrganizationRepresentation
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdMembersUserIdOrganizationsGetExecute(r ApiAdminRealmsRealmOrganizationsIdMembersUserIdOrganizationsGetRequest) ([]OrganizationRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []OrganizationRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsIdMembersUserIdOrganizationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{id}/members/{userId}/organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsIdPutRequest struct {
	ctx                        context.Context
	ApiService                 *OrganizationsAPIService
	realm                      string
	id                         string
	organizationRepresentation *OrganizationRepresentation
}

func (r ApiAdminRealmsRealmOrganizationsIdPutRequest) OrganizationRepresentation(organizationRepresentation OrganizationRepresentation) ApiAdminRealmsRealmOrganizationsIdPutRequest {
	r.organizationRepresentation = &organizationRepresentation
	return r
}

func (r ApiAdminRealmsRealmOrganizationsIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsIdPutExecute(r)
}

/*
AdminRealmsRealmOrganizationsIdPut Updates the organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiAdminRealmsRealmOrganizationsIdPutRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdPut(ctx context.Context, realm string, id string) ApiAdminRealmsRealmOrganizationsIdPutRequest {
	return ApiAdminRealmsRealmOrganizationsIdPutRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsIdPutExecute(r ApiAdminRealmsRealmOrganizationsIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.organizationRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsMembersIdOrganizationsGetRequest struct {
	ctx        context.Context
	ApiService *OrganizationsAPIService
	realm      string
	id         string
}

func (r ApiAdminRealmsRealmOrganizationsMembersIdOrganizationsGetRequest) Execute() ([]OrganizationRepresentation, *http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsMembersIdOrganizationsGetExecute(r)
}

/*
AdminRealmsRealmOrganizationsMembersIdOrganizationsGet Returns the organizations associated with the user that has the specified id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiAdminRealmsRealmOrganizationsMembersIdOrganizationsGetRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsMembersIdOrganizationsGet(ctx context.Context, realm string, id string) ApiAdminRealmsRealmOrganizationsMembersIdOrganizationsGetRequest {
	return ApiAdminRealmsRealmOrganizationsMembersIdOrganizationsGetRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return	[]OrganizationRepresentation
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsMembersIdOrganizationsGetExecute(r ApiAdminRealmsRealmOrganizationsMembersIdOrganizationsGetRequest) ([]OrganizationRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []OrganizationRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsMembersIdOrganizationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations/members/{id}/organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAdminRealmsRealmOrganizationsPostRequest struct {
	ctx                        context.Context
	ApiService                 *OrganizationsAPIService
	realm                      string
	organizationRepresentation *OrganizationRepresentation
}

func (r ApiAdminRealmsRealmOrganizationsPostRequest) OrganizationRepresentation(organizationRepresentation OrganizationRepresentation) ApiAdminRealmsRealmOrganizationsPostRequest {
	r.organizationRepresentation = &organizationRepresentation
	return r
}

func (r ApiAdminRealmsRealmOrganizationsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AdminRealmsRealmOrganizationsPostExecute(r)
}

/*
AdminRealmsRealmOrganizationsPost Creates a new organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return ApiAdminRealmsRealmOrganizationsPostRequest
*/
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsPost(ctx context.Context, realm string) ApiAdminRealmsRealmOrganizationsPostRequest {
	return ApiAdminRealmsRealmOrganizationsPostRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
func (a *OrganizationsAPIService) AdminRealmsRealmOrganizationsPostExecute(r ApiAdminRealmsRealmOrganizationsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrganizationsAPIService.AdminRealmsRealmOrganizationsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/realms/{realm}/organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.organizationRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
